#!/usr/bin/env python3
"""
üöÄ Live Trading Bot - Simulador de Trading en Tiempo Real
Bot de trading que muestra logs simples en consola
"""

import asyncio
import os
import sys
import logging
from datetime import datetime, timedelta
from typing import Dict, List
from colorama import Fore, Back, Style, init

# Inicializar colorama para colores en terminal
init(autoreset=True)

# Agregar el directorio ra√≠z del proyecto al path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(project_root)

from src.core.trading_bot import TradingBot
from src.config.main_config import TradingBotConfig, PRODUCTION_MODE, PAPER_TRADING_ONLY, ENABLE_REAL_TRADING, VERBOSE_LOGGING
# Base de datos eliminada - usando Capital.com directamente

# Configurar logging con colores
class ColoredFormatter(logging.Formatter):
    """Formatter personalizado para agregar colores a los logs"""
    
    COLORS = {
        'DEBUG': Fore.CYAN,
        'INFO': Fore.GREEN,
        'WARNING': Fore.YELLOW,
        'ERROR': Fore.RED,
        'CRITICAL': Fore.MAGENTA + Style.BRIGHT
    }
    
    def format(self, record):
        # Aplicar color seg√∫n el nivel
        color = self.COLORS.get(record.levelname, '')
        record.levelname = f"{color}{record.levelname}{Style.RESET_ALL}"
        
        # Colorear mensajes espec√≠ficos
        message = record.getMessage()
        
        # Colores para diferentes tipos de procesos
        if "üìä Analizando" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîÑ INICIANDO CICLO" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞" in message and "Precio actual" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìà" in message and "RSI" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "üéØ DECISI√ìN FINAL" in message:
            message = f"{Fore.GREEN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚úÖ TRADE EJECUTADO" in message:
            message = f"{Fore.GREEN + Back.BLACK + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìã CONFIGURACI√ìN DE ESTRATEGIAS" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞ CONFIGURACI√ìN DEL PAPER TRADER" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚öôÔ∏è CONFIGURACI√ìN DEL BOT" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("üéØ") and ":" in message:
            message = f"{Fore.CYAN}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("‚Ä¢"):
            message = f"{Fore.WHITE + Style.DIM}{message}{Style.RESET_ALL}"
        elif "‚ö†Ô∏è" in message:
            message = f"{Fore.YELLOW}{message}{Style.RESET_ALL}"
        elif "‚ùå" in message:
            message = f"{Fore.RED}{message}{Style.RESET_ALL}"
        elif "üöÄ" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üíº Ejecutando trade" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîç Ejecutando estrategia" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "‚û°Ô∏è" in message:
            message = f"{Fore.BLUE}{message}{Style.RESET_ALL}"
        elif "üîß AJUSTE DIN√ÅMICO EJECUTADO" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üõ°Ô∏è" in message and "STOP LOSS" in message:
            message = f"{Fore.RED + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üéØ" in message and "TAKE PROFIT" in message:
            message = f"{Fore.GREEN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        
        record.msg = message
        return super().format(record)

# Configurar logger con colores (sin duplicaci√≥n)
logger = logging.getLogger(__name__)
log_level = logging.DEBUG if VERBOSE_LOGGING else logging.INFO
logger.setLevel(log_level)

# Limpiar handlers existentes para evitar duplicaci√≥n
logger.handlers.clear()

# Aplicar el formatter con colores
handler = logging.StreamHandler()
handler.setFormatter(ColoredFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(handler)

# Evitar que los logs se propaguen al logger ra√≠z
logger.propagate = False

class LiveTradingBot:
    """
    üöÄ Bot de trading en vivo con logs simples
    """
    
    def __init__(self):
        self.config = TradingBotConfig()
        self.trading_bot = TradingBot()
        
        # Verificaciones de modo de operaci√≥n
        if PRODUCTION_MODE:
            if not PAPER_TRADING_ONLY:
                logger.warning("‚ö†Ô∏è  PRODUCTION MODE: Paper trading is disabled!")
            if ENABLE_REAL_TRADING:
                logger.warning("‚ö†Ô∏è  PRODUCTION MODE: Real trading is enabled!")
            logger.info("üè≠ Live Trading Bot running in PRODUCTION MODE")
        else:
            logger.info("üß™ Live Trading Bot running in DEVELOPMENT MODE")
        
        # Configuraci√≥n del bot
        self.symbols = TradingBotConfig.SYMBOLS_LIVE_BOT
        # Intervalo de an√°lisis configurado en minutos; convertir a segundos para asyncio.sleep
        self.update_interval_minutes = self.config.get_live_update_interval()
        self.update_interval = max(60, int(self.update_interval_minutes * 60))
        self.running = False
        
        # Inicializar estrategias del trading bot
        logger.info("üîß Inicializando estrategias de trading...")
        try:
            # Forzar inicializaci√≥n de estrategias
            self.trading_bot._initialize_strategies()
            logger.info(f"‚úÖ {len(self.trading_bot.strategies)} estrategias inicializadas")
            
            # Mostrar informaci√≥n detallada de cada estrategia
            logger.info("üìã CONFIGURACI√ìN DE ESTRATEGIAS:")
            for strategy_name, strategy in self.trading_bot.strategies.items():
                logger.info(f"   üéØ {strategy_name}:")
                logger.info(f"      ‚Ä¢ Confianza m√≠nima: {strategy.min_confidence}%")
                if hasattr(strategy, 'rsi_oversold'):
                    logger.info(f"      ‚Ä¢ RSI Sobreventa: {strategy.rsi_oversold}")
                if hasattr(strategy, 'rsi_overbought'):
                    logger.info(f"      ‚Ä¢ RSI Sobrecompra: {strategy.rsi_overbought}")
                if hasattr(strategy, 'stop_loss_pct'):
                    logger.info(f"      ‚Ä¢ Stop Loss: {strategy.stop_loss_pct}%")
                if hasattr(strategy, 'take_profit_pct'):
                    logger.info(f"      ‚Ä¢ Take Profit: {strategy.take_profit_pct}%")
            
            # Mostrar configuraci√≥n del Paper Trader
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            logger.info("üí∞ CONFIGURACI√ìN DEL PAPER TRADER:")
            logger.info(f"   ‚Ä¢ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"   ‚Ä¢ Tama√±o m√°ximo por posici√≥n: {self.trading_bot.paper_trader.max_position_size*100:.1f}%")
            logger.info(f"   ‚Ä¢ Exposici√≥n m√°xima total: {self.trading_bot.paper_trader.max_total_exposure*100:.1f}%")
            logger.info(f"   ‚Ä¢ Valor m√≠nimo por trade: ${self.trading_bot.paper_trader.min_trade_value}")
            logger.info(f"   ‚Ä¢ Valor actual del portfolio: ${portfolio_performance.get('total_value', 0.0):,.2f}")
            
            # Mostrar configuraci√≥n del bot
            logger.info("‚öôÔ∏è CONFIGURACI√ìN DEL BOT:")
            logger.info(f"   ‚Ä¢ S√≠mbolos: {', '.join(self.symbols)}")
            logger.info(f"   ‚Ä¢ Intervalo de an√°lisis: {self.update_interval_minutes} minutos ({self.update_interval} segundos)")
            logger.info(f"   ‚Ä¢ Confianza m√≠nima para trades: {self.config.get_min_confidence_threshold()}%")
            
            # Ajustes de TP/SL desactivados (Opci√≥n A): no configurar callback
            # try:
            #     if hasattr(self.trading_bot, 'position_adjuster') and self.trading_bot.position_adjuster:
            #         self.trading_bot.position_adjuster.set_adjustment_callback(self._display_adjustment_event)
            #         logger.info("‚úÖ Callback de ajustes de posici√≥n configurado")
            # except Exception as adj_e:
            #     logger.error(f"‚ö†Ô∏è Error configurando callback de ajustes: {adj_e}")
            
            # Configurar callback para eventos de trades
            try:
                if hasattr(self.trading_bot, 'set_trade_event_callback'):
                    self.trading_bot.set_trade_event_callback(self._display_trade_event)
                    logger.info("‚úÖ Callback de eventos de trade configurado")
            except Exception as trade_e:
                logger.error(f"‚ö†Ô∏è Error configurando callback de trades: {trade_e}")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando estrategias: {e}")
        
        self.last_signals = {}
        self.session_stats = {
            "start_time": datetime.now(),
            "total_trades": 0,
            "successful_trades": 0,
            "total_pnl": 0.0,
            "last_known_trades": 0,
            "last_known_successful": 0
        }
        

    
    def get_status(self):
        """Obtener estado del bot delegando al TradingBot interno"""
        try:
            bot_status = self.trading_bot.get_status()
            # Asegurar que siempre retornemos un diccionario
            if not isinstance(bot_status, dict):
                bot_status = {"status": str(bot_status)}
            
            # Agregar informaci√≥n espec√≠fica del live bot
            live_status = {
                "is_running": self.running,
                "uptime": str(datetime.now() - self.session_stats['start_time']),
                "total_trades": self.session_stats['total_trades'],
                "successful_trades": self.session_stats['successful_trades'],
                "session_pnl": self.session_stats['total_pnl']
            }
            
            return {**bot_status, **live_status}
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo estado: {e}")
            return {
                "error": str(e),
                "is_running": getattr(self, 'running', False),
                "total_trades": 0
            }
    
    def get_detailed_report(self) -> Dict:
        """Obtener reporte detallado del bot delegando al TradingBot interno"""
        return self.trading_bot.get_detailed_report()
    
    def get_statistics(self) -> Dict:
        """Obtener estad√≠sticas del live trading bot"""
        try:
            # Obtener estad√≠sticas del trading bot interno
            bot_stats = self.trading_bot.get_statistics() if hasattr(self.trading_bot, 'get_statistics') else {}
            
            # Calcular estad√≠sticas de la sesi√≥n
            session_duration = datetime.now() - self.session_stats['start_time']
            success_rate = (self.session_stats['successful_trades'] / max(1, self.session_stats['total_trades'])) * 100
            
            live_stats = {
                "session_duration_minutes": session_duration.total_seconds() / 60,
                "total_trades": self.session_stats['total_trades'],
                "successful_trades": self.session_stats['successful_trades'],
                "failed_trades": self.session_stats['total_trades'] - self.session_stats['successful_trades'],
                "success_rate_percent": round(success_rate, 2),
                "total_pnl": self.session_stats['total_pnl'],
                "average_pnl_per_trade": self.session_stats['total_pnl'] / max(1, self.session_stats['total_trades']),
                "symbols_traded": list(self.symbols),
                "is_running": self.running,
                "update_interval_seconds": self.update_interval
            }
            
            return {**bot_stats, **live_stats}
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo estad√≠sticas: {e}")
            return {
                "error": str(e),
                "total_trades": 0,
                "success_rate_percent": 0.0
            }
    
    def get_configuration(self) -> Dict:
        """
        üìã Obtener configuraci√≥n actual del live trading bot
        """
        try:
            # Obtener configuraci√≥n del trading bot interno
            bot_config = self.trading_bot.get_configuration()
            
            # A√±adir configuraci√≥n espec√≠fica del live bot
            live_config = {
                'live_symbols': self.symbols,
                'update_interval_seconds': self.update_interval,
                'is_live_running': self.running,
                'session_start_time': self.session_stats['start_time'].isoformat(),
                'session_total_trades': self.session_stats['total_trades'],
                'session_successful_trades': self.session_stats['successful_trades'],
                'session_total_pnl': self.session_stats['total_pnl']
            }
            
            # Combinar configuraciones
            return {**bot_config, **live_config}
            
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo configuraci√≥n del live bot: {e}")
            return {}
    

    
    async def analyze_and_trade(self):
        """üîç Analizar mercado y ejecutar trades"""
        try:
            logger.info(f"üîÑ INICIANDO CICLO DE AN√ÅLISIS - {datetime.now().strftime('%H:%M:%S')}")
            
            for symbol in self.symbols:
                logger.info(f"üìä Analizando {symbol}...")
                
                # Obtener precio actual usando fuente centralizada con cache TTL
                try:
                    current_price = float(self.trading_bot._get_current_price(symbol))
                    logger.info(f"üí∞ {symbol} - Precio actual: ${current_price:,.2f}")
                except Exception as e:
                    logger.error(f"‚ùå Error obteniendo precio para {symbol}: {e}")
                    current_price = 0.0
                
                # Analizar con cada estrategia del trading bot (igual que trading_bot.py)
                all_signals = []
                
                for strategy_name, strategy in self.trading_bot.strategies.items():
                    try:
                        logger.info(f"üîç Ejecutando estrategia {strategy_name} para {symbol}")
                        
                        # Obtener datos de mercado para mostrar indicadores
                        try:
                            df = strategy.get_market_data(symbol, "1h", 50)
                            if not df.empty:
                                last_close = df['close'].iloc[-1]
                                volume_avg = df['volume'].rolling(20).mean().iloc[-1]
                                current_volume = df['volume'].iloc[-1]
                                
                                # Calcular algunos indicadores b√°sicos
                                import pandas_ta as ta
                                rsi = ta.rsi(df['close'], length=14).iloc[-1]
                                sma_20 = ta.sma(df['close'], length=20).iloc[-1]
                                sma_50 = ta.sma(df['close'], length=50).iloc[-1]
                                
                                logger.info(f"üìà {symbol} - RSI: {rsi:.1f}, SMA20: ${sma_20:.2f}, SMA50: ${sma_50:.2f}")
                                logger.info(f"üìä {symbol} - Volumen: {current_volume:,.0f} (Promedio: {volume_avg:,.0f})")
                                
                        except Exception as e:
                            logger.error(f"‚ùå Error obteniendo indicadores para {symbol}: {e}")
                        
                        # Ejecutar an√°lisis de la estrategia
                        signal = strategy.analyze(symbol)
                        
                        logger.info(f"‚û°Ô∏è {strategy_name} - {symbol}: {signal.signal_type} (Confianza: {signal.confidence_score:.1f}%)")
                        
                        # Agregar se√±al a la lista si no es HOLD
                        if signal.signal_type != "HOLD":
                            all_signals.append(signal)
                            
                    except Exception as e:
                        logger.error(f"‚ùå Error en estrategia {strategy_name} para {symbol}: {e}")
                
                # Procesar se√±ales usando la misma l√≥gica que trading_bot.py
                if all_signals:
                    self._process_signals_for_symbol(symbol, all_signals)
                else:
                    logger.info(f"‚ö™ No se generaron se√±ales de trading para {symbol}")
                    self.last_signals[symbol] = {
                        'signal': None,
                        'timestamp': datetime.now(),
                        'action': 'HOLD'
                    }
                

                
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico en an√°lisis: {e}")
            import traceback
            traceback.print_exc()
    

    def _display_adjustment_event(self, adjustment_result):
        """
        üîß Mostrar eventos de ajustes din√°micos de TP/SL
        
        Args:
            adjustment_result: Resultado del ajuste de posici√≥n
        """
        try:
            if not adjustment_result:
                return
                
            symbol = adjustment_result.get('symbol', 'UNKNOWN')
            adjustment_type = adjustment_result.get('adjustment_type', 'UNKNOWN')
            old_value = adjustment_result.get('old_value', 0)
            new_value = adjustment_result.get('new_value', 0)
            reason = adjustment_result.get('reason', 'UNKNOWN')
            timestamp = adjustment_result.get('timestamp', datetime.now())
            
            # Formatear timestamp
            time_str = timestamp.strftime('%H:%M:%S') if hasattr(timestamp, 'strftime') else str(timestamp)
            
            # Determinar emoji y color seg√∫n el tipo de ajuste
            if 'STOP_LOSS' in adjustment_type.upper():
                emoji = "üõ°Ô∏è"
                action_color = Fore.RED + Style.BRIGHT
                action_name = "STOP LOSS"
            elif 'TAKE_PROFIT' in adjustment_type.upper():
                emoji = "üéØ"
                action_color = Fore.GREEN + Style.BRIGHT
                action_name = "TAKE PROFIT"
            else:
                emoji = "üîß"
                action_color = Fore.YELLOW + Style.BRIGHT
                action_name = adjustment_type
            
            # Mostrar el evento de ajuste
            logger.info(f"")
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"{action_color}üîß AJUSTE DIN√ÅMICO EJECUTADO - {time_str}{Style.RESET_ALL}")
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"üìä S√çMBOLO:     {symbol}")
            logger.info(f"üîÑ TIPO:        {action_name}")
            logger.info(f"üìâ VALOR ANTERIOR: ${old_value:,.4f}")
            logger.info(f"üìà VALOR NUEVO:    ${new_value:,.4f}")
            logger.info(f"üí° RAZ√ìN:       {reason}")
            
            # Calcular y mostrar el cambio
            if old_value and new_value:
                change_pct = ((new_value - old_value) / old_value) * 100
                change_direction = "üìà" if change_pct > 0 else "üìâ"
                logger.info(f"{change_direction} CAMBIO:      {change_pct:+.2f}%")
            
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"")
            
        except Exception as e:
             logger.error(f"‚ùå Error mostrando evento de ajuste: {e}")
    
    def _display_trade_event(self, trade_event):
        """
        üíº Mostrar eventos de trades ejecutados por el TradingBot
        
        Args:
            trade_event: Evento de trade ejecutado
        """
        try:
            if not trade_event:
                return
                
            symbol = trade_event.get('symbol', 'UNKNOWN')
            signal_type = trade_event.get('signal_type', 'UNKNOWN')
            confidence = trade_event.get('confidence', 0)
            entry_price = trade_event.get('entry_price', 0)
            quantity = trade_event.get('quantity', 0)
            trade_value = trade_event.get('trade_value', 0)
            success = trade_event.get('success', False)
            message = trade_event.get('message', '')
            risk_score = trade_event.get('risk_score', 0)
            risk_level = trade_event.get('risk_level', 'UNKNOWN')
            stop_loss = trade_event.get('stop_loss')
            take_profit = trade_event.get('take_profit')
            timestamp = trade_event.get('timestamp', datetime.now())
            
            # Formatear timestamp
            time_str = timestamp.strftime('%H:%M:%S') if hasattr(timestamp, 'strftime') else str(timestamp)
            
            # Determinar emoji y color seg√∫n el tipo de se√±al
            if signal_type.upper() == 'BUY':
                signal_emoji = "üìà"
                signal_color = Fore.GREEN + Style.BRIGHT
            elif signal_type.upper() == 'SELL':
                signal_emoji = "üìâ"
                signal_color = Fore.RED + Style.BRIGHT
            else:
                signal_emoji = "üîÑ"
                signal_color = Fore.YELLOW + Style.BRIGHT
            
            # Determinar estado del trade
            status_emoji = "‚úÖ" if success else "‚ùå"
            status_color = Fore.GREEN if success else Fore.RED
            
            # Mostrar el evento de trade
            logger.info(f"")
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"{signal_color}{signal_emoji} TRADE EJECUTADO POR TRADING BOT - {time_str}{Style.RESET_ALL}")
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"üìä S√çMBOLO:     {symbol}")
            logger.info(f"üéØ SE√ëAL:       {signal_type} (Confianza: {confidence:.1f}%)")
            logger.info(f"üí∞ PRECIO:      ${entry_price:,.4f}")
            logger.info(f"üì¶ CANTIDAD:    {quantity:.8f}")
            logger.info(f"üíµ VALOR:       ${trade_value:,.2f}")
            logger.info(f"{status_color}üìã ESTADO:      {status_emoji} {message}{Style.RESET_ALL}")
            logger.info(f"üõ°Ô∏è RIESGO:      {risk_score:.1f}/100 ({risk_level})")
            
            # Mostrar TP/SL si est√°n disponibles
            if stop_loss:
                logger.info(f"üõ°Ô∏è STOP LOSS:   ${stop_loss:,.4f}")
            if take_profit:
                logger.info(f"üéØ TAKE PROFIT: ${take_profit:,.4f}")
            
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"")
            
        except Exception as e:
            logger.error(f"‚ùå Error mostrando evento de trade: {e}")
     
    def _process_signals_for_symbol(self, symbol: str, signals):
        """
        üéØ Procesar y ejecutar se√±ales de trading para un s√≠mbolo espec√≠fico
        
        Args:
            symbol: S√≠mbolo del activo
            signals: Lista de se√±ales generadas para este s√≠mbolo
        """
        try:
            # Filtrar se√±ales por confianza m√≠nima
            high_confidence_signals = [
                signal for signal in signals 
                if signal.confidence_score >= self.trading_bot.min_confidence_threshold
            ]
            
            if not high_confidence_signals:
                logger.info(f"üìâ No hay se√±ales por encima del umbral de confianza ({self.trading_bot.min_confidence_threshold}%) para {symbol}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'HOLD'
                }
                return
            
            # Ordenar por confianza (mayor primero)
            high_confidence_signals.sort(key=lambda x: x.confidence_score, reverse=True)
            
            # Obtener valor actual del portfolio (simplificado - sin base de datos)
            portfolio_value = self.trading_bot.config.DEFAULT_PORTFOLIO_VALUE
            
            logger.info(f"üíº Valor actual del portfolio: ${portfolio_value:,.2f}")
            
            # Procesar la mejor se√±al para este s√≠mbolo
            best_signal = high_confidence_signals[0]
            
            try:
                # Verificar l√≠mite diario
                if self.trading_bot.stats["daily_trades"] >= self.trading_bot.max_daily_trades:
                    logger.info("‚è∏Ô∏è L√≠mite diario de trades alcanzado")
                    return
                
                # An√°lisis de riesgo
                risk_assessment = self.trading_bot.risk_manager.assess_trade_risk(best_signal, portfolio_value)
                
                logger.info(f"üõ°Ô∏è Evaluaci√≥n de riesgo para {best_signal.symbol}:")
                logger.info(f"   - Puntuaci√≥n de Riesgo: {risk_assessment.overall_risk_score:.1f}/100")
                logger.info(f"   - Tama√±o de Posici√≥n: {risk_assessment.position_sizing.recommended_size:.2f}")
                logger.info(f"   - Aprobado: {risk_assessment.is_approved}")
                logger.info(f"   - Nivel de Riesgo: {risk_assessment.risk_level.value}")
                
                # Ejecutar si est√° aprobado - usar el m√©todo del trading_bot que maneja real trading
                if risk_assessment.is_approved and self.trading_bot.enable_trading:
                    logger.info(f"üîÑ Procesando se√±al con trading_bot._process_signals para {best_signal.symbol}")
                    logger.info(f"üîß Real trading habilitado: {self.trading_bot.enable_real_trading}")
                    logger.info(f"üîß Capital client disponible: {self.trading_bot.capital_client is not None}")
                    
                    # Usar el m√©todo del trading_bot que maneja tanto paper como real trading
                    self.trading_bot._process_signals([best_signal])
                    
                    # Actualizar estad√≠sticas locales bas√°ndose en las estad√≠sticas del trading_bot
                    current_trades = self.trading_bot.stats["trades_executed"]
                    current_daily_trades = self.trading_bot.stats["daily_trades"]
                    current_successful_trades = self.trading_bot.stats["successful_trades"]
                    
                    # Verificar si se ejecut√≥ un nuevo trade
                    if current_trades > self.session_stats.get("last_known_trades", 0):
                        self.session_stats["total_trades"] += 1
                        self.session_stats["last_known_trades"] = current_trades
                        
                        # Verificar si fue exitoso
                        if current_successful_trades > self.session_stats.get("last_known_successful", 0):
                            self.session_stats["successful_trades"] += 1
                            self.session_stats["last_known_successful"] = current_successful_trades
                        
                        logger.info(f"‚úÖ Se√±al procesada por trading_bot para {best_signal.symbol}")
                        
                        # Actualizar last_signals con la se√±al ejecutada
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': best_signal.signal_type,
                            'confidence': best_signal.confidence_score,
                            'executed': True
                        }
                    else:
                        logger.warning(f"‚ùå No se ejecut√≥ trade para {best_signal.symbol}")
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': 'FAILED',
                            'confidence': best_signal.confidence_score,
                            'executed': False
                        }
                
                elif not risk_assessment.is_approved:
                    rejection_reason = f"Nivel de riesgo: {risk_assessment.risk_level.value}"
                    logger.info(f"üö´ Trade rechazado: {rejection_reason}")
                    
                    # Mostrar recomendaciones
                    for rec in risk_assessment.recommendations:
                        logger.info(f"   üí° {rec}")
                    
                    # Actualizar last_signals con la se√±al rechazada
                    self.last_signals[symbol] = {
                        'signal': best_signal,
                        'timestamp': datetime.now(),
                        'action': 'REJECTED',
                        'confidence': best_signal.confidence_score,
                        'executed': False,
                        'rejection_reason': rejection_reason
                    }
                
            except Exception as e:
                logger.error(f"‚ùå Error procesando se√±al para {best_signal.symbol}: {e}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'ERROR',
                    'error': str(e)
                }
            
            # Actualizar P&L total
            try:
                portfolio_summary = self.trading_bot.paper_trader.get_portfolio_summary()
                self.trading_bot.stats["total_pnl"] = portfolio_summary.get("total_pnl", 0)
            except Exception as e:
                logger.debug(f"No se pudo obtener portfolio_summary: {e}")
                self.trading_bot.stats["total_pnl"] = 0
            
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico procesando se√±ales para {symbol}: {e}")
            import traceback
            traceback.print_exc()
    
    async def start(self):
        """üöÄ Iniciar el bot de trading en vivo"""
        self.running = True
        logger.info("üöÄ Iniciando Live Trading Bot...")
        logger.info("‚ö†Ô∏è Modo: Paper Trading (Sin dinero real)")
        logger.info("Presiona Ctrl+C para detener")
        
        # Iniciar el TradingBot interno y su position_monitor
        try:
            logger.info("üîß Iniciando TradingBot interno y position_monitor...")
            self.trading_bot.start()  # Esto inicia el position_monitor autom√°ticamente
            logger.info("‚úÖ TradingBot interno y position_monitor iniciados correctamente")
        except Exception as e:
            logger.error(f"‚ùå Error iniciando TradingBot interno: {e}")
            return
        
        # Contador de ciclos para debug
        cycle_count = 0
        
        try:
            while self.running:
                cycle_count += 1
                logger.info(f"üîÑ Ciclo #{cycle_count} - {datetime.now().strftime('%H:%M:%S')}")
                
                # Analizar mercado y ejecutar trades
                await self.analyze_and_trade()
                
                # Mostrar estad√≠sticas actuales
                self.show_current_stats()
                
                logger.info(f"‚è±Ô∏è Esperando {self.update_interval_minutes} minutos ({self.update_interval} segundos) antes del pr√≥ximo an√°lisis...")
                
                # Esperar antes del siguiente ciclo
                await asyncio.sleep(self.update_interval)
                    
        except KeyboardInterrupt:
            logger.info("üõë Bot detenido por el usuario")
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.running = False
            
            # Detener el TradingBot interno y su position_monitor
            try:
                logger.info("üõë Deteniendo TradingBot interno y position_monitor...")
                self.trading_bot.stop()
                logger.info("‚úÖ TradingBot interno detenido correctamente")
            except Exception as e:
                logger.error(f"‚ùå Error deteniendo TradingBot interno: {e}")
            
            # Mostrar resumen final
            self.show_final_summary()
    
    def show_current_stats(self):
        """üìä Mostrar estad√≠sticas actuales usando datos del TradingBot"""
        try:
            # Intentar obtener portfolio_performance, si no existe usar valores por defecto
            try:
                portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            except AttributeError:
                portfolio_performance = {'total_value': 0.0, 'total_pnl': 0.0, 'total_return_percentage': 0.0}
            
            portfolio_summary = self.trading_bot.paper_trader.get_portfolio_summary()
            
            # Obtener balance de USD correctamente
            current_balance = self.trading_bot.paper_trader.get_balance('USD')
            total_value = portfolio_performance.get('total_value', 0.0)
            pnl = portfolio_performance.get('total_pnl', 0.0)
            pnl_pct = portfolio_performance.get('total_return_percentage', 0.0)
            
            logger.info("\n" + "="*60)
            logger.info("üìä ESTAD√çSTICAS ACTUALES")
            logger.info("="*60)
            logger.info(f"üí∞ Balance actual: ${current_balance:,.2f}")
            logger.info(f"üìà Valor total del portfolio: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Trades totales: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Tasa de √©xito: {success_rate:.1f}%")
            
            # Mostrar balances de cada activo
            logger.info("\nü™ô BALANCES POR ACTIVO:")
            assets = portfolio_summary.get('assets', [])
            if assets:
                for asset in assets:
                    symbol = asset.get('symbol', '')
                    quantity = asset.get('quantity', 0)
                    current_value = asset.get('current_value', 0)
                    
                    if symbol == 'USD':
                        # Para USD solo mostrar el valor
                        logger.info(f"   üíµ {symbol}: ${current_value:,.2f}")
                    else:
                        # Para otros activos mostrar cantidad y valor en USD
                        logger.info(f"   ü™ô {symbol}: {quantity:.6f} (${current_value:,.2f})")
            else:
                logger.info("   üì≠ No hay activos en el portfolio")
            
            logger.info("="*60 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando estad√≠sticas: {e}")
    
    def show_final_summary(self):
        """üìã Mostrar resumen final de la sesi√≥n usando datos del TradingBot"""
        try:
            session_duration = datetime.now() - self.session_stats['start_time']
            # Intentar obtener portfolio_performance, si no existe usar valores por defecto
            try:
                portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            except AttributeError:
                portfolio_performance = {'total_value': 0.0, 'total_pnl': 0.0, 'total_return_percentage': 0.0}
            # Obtener balance final de USD correctamente
            final_balance = self.trading_bot.paper_trader.get_balance('USD')
            total_value = portfolio_performance.get('total_value', 0.0)
            total_pnl = portfolio_performance.get('total_pnl', 0.0)
            pnl_pct = portfolio_performance.get('total_return_percentage', 0.0)
            
            logger.info("\n" + "="*80)
            logger.info("üèÅ RESUMEN FINAL DE LA SESI√ìN")
            logger.info("="*80)
            logger.info(f"‚è±Ô∏è Duraci√≥n de la sesi√≥n: {session_duration}")
            logger.info(f"üí∞ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"üí∞ Balance final: ${final_balance:,.2f}")
            logger.info(f"üìà Valor total final: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${total_pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Total de trades: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Trades exitosos: {self.session_stats['successful_trades']} ({success_rate:.1f}%)")
                avg_pnl = total_pnl / self.session_stats['total_trades']
                logger.info(f"üìä PnL promedio por trade: ${avg_pnl:.2f}")
            logger.info("="*80)
            logger.info("üôè ¬°Gracias por usar el Live Trading Bot!")
            logger.info("="*80 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando resumen final: {e}")

async def main():
    """üéØ Funci√≥n principal"""
    try:
        bot = LiveTradingBot()
        await bot.start()
    except KeyboardInterrupt:
        logger.info("üõë Bot detenido por el usuario")
    except Exception as e:
        logger.error(f"‚ùå Error cr√≠tico en main: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass  # Ya manejado en main()