#!/usr/bin/env python3
"""
üöÄ Live Trading Bot - Simulador de Trading en Tiempo Real
Bot de trading que muestra logs simples en consola
"""

import asyncio
import os
import sys
import logging
from datetime import datetime, timedelta
from typing import Dict, List
from colorama import Fore, Back, Style, init

# Inicializar colorama para colores en terminal
init(autoreset=True)

# Agregar el directorio ra√≠z del proyecto al path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(project_root)

from src.core.trading_bot import TradingBot
from src.config.config import TradingBotConfig
from src.database.database import db_manager

# Configurar logging con colores
class ColoredFormatter(logging.Formatter):
    """Formatter personalizado para agregar colores a los logs"""
    
    COLORS = {
        'DEBUG': Fore.CYAN,
        'INFO': Fore.GREEN,
        'WARNING': Fore.YELLOW,
        'ERROR': Fore.RED,
        'CRITICAL': Fore.MAGENTA + Style.BRIGHT
    }
    
    def format(self, record):
        # Aplicar color seg√∫n el nivel
        color = self.COLORS.get(record.levelname, '')
        record.levelname = f"{color}{record.levelname}{Style.RESET_ALL}"
        
        # Colorear mensajes espec√≠ficos
        message = record.getMessage()
        
        # Colores para diferentes tipos de procesos
        if "üìä Analizando" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîÑ INICIANDO CICLO" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞" in message and "Precio actual" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìà" in message and "RSI" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "üéØ DECISI√ìN FINAL" in message:
            message = f"{Fore.GREEN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚úÖ TRADE EJECUTADO" in message:
            message = f"{Fore.GREEN + Back.BLACK + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìã CONFIGURACI√ìN DE ESTRATEGIAS" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞ CONFIGURACI√ìN DEL PAPER TRADER" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚öôÔ∏è CONFIGURACI√ìN DEL BOT" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("üéØ") and ":" in message:
            message = f"{Fore.CYAN}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("‚Ä¢"):
            message = f"{Fore.WHITE + Style.DIM}{message}{Style.RESET_ALL}"
        elif "‚ö†Ô∏è" in message:
            message = f"{Fore.YELLOW}{message}{Style.RESET_ALL}"
        elif "‚ùå" in message:
            message = f"{Fore.RED}{message}{Style.RESET_ALL}"
        elif "üöÄ" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üíº Ejecutando trade" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîç Ejecutando estrategia" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "‚û°Ô∏è" in message:
            message = f"{Fore.BLUE}{message}{Style.RESET_ALL}"
        elif "üîß AJUSTE DIN√ÅMICO EJECUTADO" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üõ°Ô∏è" in message and "STOP LOSS" in message:
            message = f"{Fore.RED + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üéØ" in message and "TAKE PROFIT" in message:
            message = f"{Fore.GREEN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        
        record.msg = message
        return super().format(record)

# Configurar logger con colores (sin duplicaci√≥n)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Limpiar handlers existentes para evitar duplicaci√≥n
logger.handlers.clear()

# Aplicar el formatter con colores
handler = logging.StreamHandler()
handler.setFormatter(ColoredFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(handler)

# Evitar que los logs se propaguen al logger ra√≠z
logger.propagate = False

class LiveTradingBot:
    """
    üöÄ Bot de trading en vivo con logs simples
    """
    
    def __init__(self):
        self.config = TradingBotConfig()
        self.trading_bot = TradingBot()
        
        # Configuraci√≥n del bot
        self.symbols = TradingBotConfig.SYMBOLS_LIVE_BOT
        self.update_interval = self.config.get_live_update_interval()
        self.running = False
        
        # Inicializar estrategias del trading bot
        logger.info("üîß Inicializando estrategias de trading...")
        try:
            # Forzar inicializaci√≥n de estrategias
            self.trading_bot._initialize_strategies()
            logger.info(f"‚úÖ {len(self.trading_bot.strategies)} estrategias inicializadas")
            
            # Mostrar informaci√≥n detallada de cada estrategia
            logger.info("üìã CONFIGURACI√ìN DE ESTRATEGIAS:")
            for strategy_name, strategy in self.trading_bot.strategies.items():
                logger.info(f"   üéØ {strategy_name}:")
                logger.info(f"      ‚Ä¢ Confianza m√≠nima: {strategy.min_confidence}%")
                if hasattr(strategy, 'rsi_oversold'):
                    logger.info(f"      ‚Ä¢ RSI Sobreventa: {strategy.rsi_oversold}")
                if hasattr(strategy, 'rsi_overbought'):
                    logger.info(f"      ‚Ä¢ RSI Sobrecompra: {strategy.rsi_overbought}")
                if hasattr(strategy, 'stop_loss_pct'):
                    logger.info(f"      ‚Ä¢ Stop Loss: {strategy.stop_loss_pct}%")
                if hasattr(strategy, 'take_profit_pct'):
                    logger.info(f"      ‚Ä¢ Take Profit: {strategy.take_profit_pct}%")
            
            # Mostrar configuraci√≥n del Paper Trader
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            logger.info("üí∞ CONFIGURACI√ìN DEL PAPER TRADER:")
            logger.info(f"   ‚Ä¢ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"   ‚Ä¢ Tama√±o m√°ximo por posici√≥n: {self.trading_bot.paper_trader.max_position_size:.1f}%")
            logger.info(f"   ‚Ä¢ Exposici√≥n m√°xima total: {self.trading_bot.paper_trader.max_total_exposure:.1f}%")
            logger.info(f"   ‚Ä¢ Valor m√≠nimo por trade: ${self.trading_bot.paper_trader.min_trade_value}")
            logger.info(f"   ‚Ä¢ Valor actual del portfolio: ${portfolio_performance.get('total_value', 0):,.2f}")
            
            # Mostrar configuraci√≥n del bot
            logger.info("‚öôÔ∏è CONFIGURACI√ìN DEL BOT:")
            logger.info(f"   ‚Ä¢ S√≠mbolos: {', '.join(self.symbols)}")
            logger.info(f"   ‚Ä¢ Intervalo de an√°lisis: {self.update_interval} segundos")
            logger.info(f"   ‚Ä¢ Confianza m√≠nima para trades: {self.config.get_min_confidence_threshold()}%")
            
            # Configurar callback para ajustes de TP/SL din√°micos
            try:
                if hasattr(self.trading_bot, 'position_adjuster') and self.trading_bot.position_adjuster:
                    self.trading_bot.position_adjuster.set_adjustment_callback(self._display_adjustment_event)
                    logger.info("‚úÖ Callback de ajustes de posici√≥n configurado")
            except Exception as adj_e:
                logger.error(f"‚ö†Ô∏è Error configurando callback de ajustes: {adj_e}")
            
            # Configurar callback para eventos de trades
            try:
                if hasattr(self.trading_bot, 'set_trade_event_callback'):
                    self.trading_bot.set_trade_event_callback(self._display_trade_event)
                    logger.info("‚úÖ Callback de eventos de trade configurado")
            except Exception as trade_e:
                logger.error(f"‚ö†Ô∏è Error configurando callback de trades: {trade_e}")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando estrategias: {e}")
        
        self.last_signals = {}
        self.session_stats = {
            "start_time": datetime.now(),
            "total_trades": 0,
            "successful_trades": 0,
            "total_pnl": 0.0
        }
    
    def get_status(self):
        """Obtener estado del bot delegando al TradingBot interno"""
        return self.trading_bot.get_status()
    
    def get_detailed_report(self) -> Dict:
        """Obtener reporte detallado del bot delegando al TradingBot interno"""
        return self.trading_bot.get_detailed_report()
    
    def get_configuration(self) -> Dict:
        """
        üìã Obtener configuraci√≥n actual del live trading bot
        """
        try:
            # Obtener configuraci√≥n del trading bot interno
            bot_config = self.trading_bot.get_configuration()
            
            # A√±adir configuraci√≥n espec√≠fica del live bot
            live_config = {
                'live_symbols': self.symbols,
                'update_interval_seconds': self.update_interval,
                'is_live_running': self.running,
                'session_start_time': self.session_stats['start_time'].isoformat(),
                'session_total_trades': self.session_stats['total_trades'],
                'session_successful_trades': self.session_stats['successful_trades'],
                'session_total_pnl': self.session_stats['total_pnl']
            }
            
            # Combinar configuraciones
            return {**bot_config, **live_config}
            
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo configuraci√≥n del live bot: {e}")
            return {}
    

    
    async def analyze_and_trade(self):
        """üîç Analizar mercado y ejecutar trades"""
        try:
            logger.info(f"üîÑ INICIANDO CICLO DE AN√ÅLISIS - {datetime.now().strftime('%H:%M:%S')}")
            
            for symbol in self.symbols:
                logger.info(f"üìä Analizando {symbol}...")
                
                # Obtener precio actual
                try:
                    import ccxt
                    exchange = ccxt.binance({'sandbox': False, 'enableRateLimit': True})
                    ticker = exchange.fetch_ticker(symbol)
                    current_price = ticker['last']
                    logger.info(f"üí∞ {symbol} - Precio actual: ${current_price:,.2f}")
                except Exception as e:
                    logger.error(f"‚ùå Error obteniendo precio para {symbol}: {e}")
                    current_price = 0
                
                # Analizar con cada estrategia del trading bot (igual que trading_bot.py)
                all_signals = []
                
                for strategy_name, strategy in self.trading_bot.strategies.items():
                    try:
                        logger.info(f"üîç Ejecutando estrategia {strategy_name} para {symbol}")
                        
                        # Obtener datos de mercado para mostrar indicadores
                        try:
                            df = strategy.get_market_data(symbol, "1h", 50)
                            if not df.empty:
                                last_close = df['close'].iloc[-1]
                                volume_avg = df['volume'].rolling(20).mean().iloc[-1]
                                current_volume = df['volume'].iloc[-1]
                                
                                # Calcular algunos indicadores b√°sicos
                                import pandas_ta as ta
                                rsi = ta.rsi(df['close'], length=14).iloc[-1]
                                sma_20 = ta.sma(df['close'], length=20).iloc[-1]
                                sma_50 = ta.sma(df['close'], length=50).iloc[-1]
                                
                                logger.info(f"üìà {symbol} - RSI: {rsi:.1f}, SMA20: ${sma_20:.2f}, SMA50: ${sma_50:.2f}")
                                logger.info(f"üìä {symbol} - Volumen: {current_volume:,.0f} (Promedio: {volume_avg:,.0f})")
                                
                        except Exception as e:
                            logger.error(f"‚ùå Error obteniendo indicadores para {symbol}: {e}")
                        
                        # Ejecutar an√°lisis de la estrategia
                        signal = strategy.analyze(symbol)
                        
                        logger.info(f"‚û°Ô∏è {strategy_name} - {symbol}: {signal.signal_type} (Confianza: {signal.confidence_score:.1f}%)")
                        
                        # Agregar se√±al a la lista si no es HOLD
                        if signal.signal_type != "HOLD":
                            all_signals.append(signal)
                            
                    except Exception as e:
                        logger.error(f"‚ùå Error en estrategia {strategy_name} para {symbol}: {e}")
                
                # Procesar se√±ales usando la misma l√≥gica que trading_bot.py
                if all_signals:
                    self._process_signals_for_symbol(symbol, all_signals)
                else:
                    logger.info(f"‚ö™ No se generaron se√±ales de trading para {symbol}")
                    self.last_signals[symbol] = {
                        'signal': None,
                        'timestamp': datetime.now(),
                        'action': 'HOLD'
                    }
                

                
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico en an√°lisis: {e}")
            import traceback
            traceback.print_exc()
    
    def _show_binance_config(self, signal, trade_result):
        """
        üìã Mostrar configuraci√≥n para replicar en Binance
        """
        try:
            # Importar configuraci√≥n din√°mica
            from src.config.config import RiskManagerConfig
            
            # Extraer datos del trade ejecutado
            symbol = signal.symbol
            signal_type = signal.signal_type
            price = trade_result.entry_price if hasattr(trade_result, 'entry_price') else signal.current_price
            
            # Calcular valores para Binance
            if signal_type == "BUY":
                # Precio ligeramente por debajo para mejor ejecuci√≥n
                binance_price = price * 0.9997  # 0.03% por debajo
                
                # Monto en cripto (del trade ejecutado)
                crypto_amount = trade_result.quantity if hasattr(trade_result, 'quantity') else 0
                
                # Total en USDT
                total_usdt = trade_result.entry_value if hasattr(trade_result, 'entry_value') else (crypto_amount * price)
                
                # Usar valores din√°micos de TP y SL desde la se√±al si est√°n disponibles
                if hasattr(signal, 'take_profit_price') and signal.take_profit_price > 0:
                    take_profit_price = signal.take_profit_price
                    take_profit_pct = ((take_profit_price - price) / price) * 100
                else:
                    # Fallback: usar configuraci√≥n din√°mica
                    tp_max = RiskManagerConfig.get_tp_max_percentage()
                    take_profit_price = price * (1 + tp_max / 100)
                    take_profit_pct = tp_max
                
                if hasattr(signal, 'stop_loss_price') and signal.stop_loss_price > 0:
                    stop_loss_price = signal.stop_loss_price
                    stop_loss_pct = ((price - stop_loss_price) / price) * 100
                else:
                    # Fallback: usar configuraci√≥n din√°mica
                    sl_max = RiskManagerConfig.get_sl_max_percentage()
                    stop_loss_price = price * (1 - sl_max / 100)
                    stop_loss_pct = sl_max
                
                logger.info("")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("üìã CONFIGURACI√ìN PARA BINANCE SPOT - ORDEN L√çMITE")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info(f"üí∞ PRECIO:     {binance_price:,.2f} USDT")
                logger.info(f"ü™ô MONTO:      {crypto_amount:.8f} {symbol.replace('USDT', '')}")
                logger.info(f"üíµ TOTAL:      {total_usdt:.2f} USDT")
                logger.info("")
                logger.info("üõ°Ô∏è PROTECCI√ìN (TP/SL):")
                logger.info(f"üìà TAKE PROFIT: {take_profit_price:,.2f} USDT (+{take_profit_pct:.1f}%)")
                logger.info(f"üìâ STOP LOSS:   {stop_loss_price:,.2f} USDT (-{stop_loss_pct:.1f}%)")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("")
                
            elif signal_type == "SELL":
                # Para ventas
                binance_price = price * 1.0003  # 0.03% por arriba
                
                # Usar datos del trade ejecutado (no el balance actual que ya es 0)
                asset_name = symbol.replace('USDT', '')
                crypto_balance = trade_result.quantity if hasattr(trade_result, 'quantity') else 0
                total_usdt = trade_result.entry_value if hasattr(trade_result, 'entry_value') else (crypto_balance * price)
                
                # Usar valores din√°micos de TP y SL desde la se√±al si est√°n disponibles
                if hasattr(signal, 'take_profit_price') and signal.take_profit_price > 0:
                    take_profit_price = signal.take_profit_price
                    take_profit_pct = ((price - take_profit_price) / price) * 100
                else:
                    # Fallback: usar configuraci√≥n din√°mica
                    tp_max = RiskManagerConfig.get_tp_max_percentage()
                    take_profit_price = price * (1 - tp_max / 100)
                    take_profit_pct = tp_max
                
                if hasattr(signal, 'stop_loss_price') and signal.stop_loss_price > 0:
                    stop_loss_price = signal.stop_loss_price
                    stop_loss_pct = ((stop_loss_price - price) / price) * 100
                else:
                    # Fallback: usar configuraci√≥n din√°mica
                    sl_max = RiskManagerConfig.get_sl_max_percentage()
                    stop_loss_price = price * (1 + sl_max / 100)
                    stop_loss_pct = sl_max
                
                logger.info("")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("üìã CONFIGURACI√ìN PARA BINANCE SPOT - VENTA L√çMITE")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info(f"üí∞ PRECIO:     {binance_price:,.2f} USDT")
                logger.info(f"ü™ô MONTO:      {crypto_balance:.8f} {asset_name}")
                logger.info(f"üíµ TOTAL:      {total_usdt:.2f} USDT")
                logger.info("")
                logger.info("üõ°Ô∏è PROTECCI√ìN (TP/SL):")
                logger.info(f"üìà TAKE PROFIT: {take_profit_price:,.2f} USDT (-{take_profit_pct:.1f}%)")
                logger.info(f"üìâ STOP LOSS:   {stop_loss_price:,.2f} USDT (+{stop_loss_pct:.1f}%)")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("")
                
        except Exception as e:
            logger.error(f"‚ùå Error mostrando configuraci√≥n de Binance: {e}")
    
    def _display_adjustment_event(self, adjustment_result):
        """
        üîß Mostrar eventos de ajustes din√°micos de TP/SL
        
        Args:
            adjustment_result: Resultado del ajuste de posici√≥n
        """
        try:
            if not adjustment_result:
                return
                
            symbol = adjustment_result.get('symbol', 'UNKNOWN')
            adjustment_type = adjustment_result.get('adjustment_type', 'UNKNOWN')
            old_value = adjustment_result.get('old_value', 0)
            new_value = adjustment_result.get('new_value', 0)
            reason = adjustment_result.get('reason', 'UNKNOWN')
            timestamp = adjustment_result.get('timestamp', datetime.now())
            
            # Formatear timestamp
            time_str = timestamp.strftime('%H:%M:%S') if hasattr(timestamp, 'strftime') else str(timestamp)
            
            # Determinar emoji y color seg√∫n el tipo de ajuste
            if 'STOP_LOSS' in adjustment_type.upper():
                emoji = "üõ°Ô∏è"
                action_color = Fore.RED + Style.BRIGHT
                action_name = "STOP LOSS"
            elif 'TAKE_PROFIT' in adjustment_type.upper():
                emoji = "üéØ"
                action_color = Fore.GREEN + Style.BRIGHT
                action_name = "TAKE PROFIT"
            else:
                emoji = "üîß"
                action_color = Fore.YELLOW + Style.BRIGHT
                action_name = adjustment_type
            
            # Mostrar el evento de ajuste
            logger.info(f"")
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"{action_color}üîß AJUSTE DIN√ÅMICO EJECUTADO - {time_str}{Style.RESET_ALL}")
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"üìä S√çMBOLO:     {symbol}")
            logger.info(f"üîÑ TIPO:        {action_name}")
            logger.info(f"üìâ VALOR ANTERIOR: ${old_value:,.4f}")
            logger.info(f"üìà VALOR NUEVO:    ${new_value:,.4f}")
            logger.info(f"üí° RAZ√ìN:       {reason}")
            
            # Calcular y mostrar el cambio
            if old_value and new_value:
                change_pct = ((new_value - old_value) / old_value) * 100
                change_direction = "üìà" if change_pct > 0 else "üìâ"
                logger.info(f"{change_direction} CAMBIO:      {change_pct:+.2f}%")
            
            logger.info(f"{emoji} ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"")
            
        except Exception as e:
             logger.error(f"‚ùå Error mostrando evento de ajuste: {e}")
    
    def _display_trade_event(self, trade_event):
        """
        üíº Mostrar eventos de trades ejecutados por el TradingBot
        
        Args:
            trade_event: Evento de trade ejecutado
        """
        try:
            if not trade_event:
                return
                
            symbol = trade_event.get('symbol', 'UNKNOWN')
            signal_type = trade_event.get('signal_type', 'UNKNOWN')
            confidence = trade_event.get('confidence', 0)
            entry_price = trade_event.get('entry_price', 0)
            quantity = trade_event.get('quantity', 0)
            trade_value = trade_event.get('trade_value', 0)
            success = trade_event.get('success', False)
            message = trade_event.get('message', '')
            risk_score = trade_event.get('risk_score', 0)
            risk_level = trade_event.get('risk_level', 'UNKNOWN')
            stop_loss = trade_event.get('stop_loss')
            take_profit = trade_event.get('take_profit')
            timestamp = trade_event.get('timestamp', datetime.now())
            
            # Formatear timestamp
            time_str = timestamp.strftime('%H:%M:%S') if hasattr(timestamp, 'strftime') else str(timestamp)
            
            # Determinar emoji y color seg√∫n el tipo de se√±al
            if signal_type.upper() == 'BUY':
                signal_emoji = "üìà"
                signal_color = Fore.GREEN + Style.BRIGHT
            elif signal_type.upper() == 'SELL':
                signal_emoji = "üìâ"
                signal_color = Fore.RED + Style.BRIGHT
            else:
                signal_emoji = "üîÑ"
                signal_color = Fore.YELLOW + Style.BRIGHT
            
            # Determinar estado del trade
            status_emoji = "‚úÖ" if success else "‚ùå"
            status_color = Fore.GREEN if success else Fore.RED
            
            # Mostrar el evento de trade
            logger.info(f"")
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"{signal_color}{signal_emoji} TRADE EJECUTADO POR TRADING BOT - {time_str}{Style.RESET_ALL}")
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"üìä S√çMBOLO:     {symbol}")
            logger.info(f"üéØ SE√ëAL:       {signal_type} (Confianza: {confidence:.1f}%)")
            logger.info(f"üí∞ PRECIO:      ${entry_price:,.4f}")
            logger.info(f"üì¶ CANTIDAD:    {quantity:.8f}")
            logger.info(f"üíµ VALOR:       ${trade_value:,.2f}")
            logger.info(f"{status_color}üìã ESTADO:      {status_emoji} {message}{Style.RESET_ALL}")
            logger.info(f"üõ°Ô∏è RIESGO:      {risk_score:.1f}/100 ({risk_level})")
            
            # Mostrar TP/SL si est√°n disponibles
            if stop_loss:
                logger.info(f"üõ°Ô∏è STOP LOSS:   ${stop_loss:,.4f}")
            if take_profit:
                logger.info(f"üéØ TAKE PROFIT: ${take_profit:,.4f}")
            
            logger.info(f"üíº ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            logger.info(f"")
            
        except Exception as e:
            logger.error(f"‚ùå Error mostrando evento de trade: {e}")
     
    def _process_signals_for_symbol(self, symbol: str, signals):
        """
        üéØ Procesar y ejecutar se√±ales de trading para un s√≠mbolo espec√≠fico
        
        Args:
            symbol: S√≠mbolo del activo
            signals: Lista de se√±ales generadas para este s√≠mbolo
        """
        try:
            # Filtrar se√±ales por confianza m√≠nima
            high_confidence_signals = [
                signal for signal in signals 
                if signal.confidence_score >= self.trading_bot.min_confidence_threshold
            ]
            
            if not high_confidence_signals:
                logger.info(f"üìâ No hay se√±ales por encima del umbral de confianza ({self.trading_bot.min_confidence_threshold}%) para {symbol}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'HOLD'
                }
                return
            
            # Ordenar por confianza (mayor primero)
            high_confidence_signals.sort(key=lambda x: x.confidence_score, reverse=True)
            
            # Obtener valor actual del portfolio
            from src.database.database import db_manager
            portfolio_summary = db_manager.get_portfolio_summary(is_paper=True)
            portfolio_value = portfolio_summary.get("total_value", self.trading_bot.config.DEFAULT_PORTFOLIO_VALUE)
            
            logger.info(f"üíº Valor actual del portfolio: ${portfolio_value:,.2f}")
            
            # Procesar la mejor se√±al para este s√≠mbolo
            best_signal = high_confidence_signals[0]
            
            try:
                # Verificar l√≠mite diario
                if self.trading_bot.stats["daily_trades"] >= self.trading_bot.max_daily_trades:
                    logger.info("‚è∏Ô∏è L√≠mite diario de trades alcanzado")
                    return
                
                # An√°lisis de riesgo
                risk_assessment = self.trading_bot.risk_manager.assess_trade_risk(best_signal, portfolio_value)
                
                logger.info(f"üõ°Ô∏è Evaluaci√≥n de riesgo para {best_signal.symbol}:")
                logger.info(f"   - Puntuaci√≥n de Riesgo: {risk_assessment.overall_risk_score:.1f}/100")
                logger.info(f"   - Tama√±o de Posici√≥n: {risk_assessment.position_sizing.recommended_size:.2f}")
                logger.info(f"   - Aprobado: {risk_assessment.is_approved}")
                logger.info(f"   - Nivel de Riesgo: {risk_assessment.risk_level.value}")
                
                # Ejecutar si est√° aprobado
                if risk_assessment.is_approved and self.trading_bot.enable_trading:
                    trade_result = self.trading_bot.paper_trader.execute_signal(best_signal)
                    
                    if trade_result.success:
                        self.trading_bot.stats["trades_executed"] += 1
                        self.trading_bot.stats["daily_trades"] += 1
                        self.session_stats["total_trades"] += 1
                        
                        # Determinar si fue exitoso (simplificado)
                        if "profit" in trade_result.message.lower() or trade_result.entry_value > 0:
                            self.trading_bot.stats["successful_trades"] += 1
                            self.session_stats["successful_trades"] += 1
                        
                        logger.info(f"‚úÖ Trade ejecutado: {trade_result.message}")
                        
                        # Mostrar configuraci√≥n para Binance
                        self._show_binance_config(best_signal, trade_result)
                        
                        # Actualizar last_signals con la se√±al ejecutada
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': best_signal.signal_type,
                            'confidence': best_signal.confidence_score,
                            'executed': True
                        }
                    else:
                        logger.warning(f"‚ùå Trade fall√≥: {trade_result.message}")
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': 'FAILED',
                            'confidence': best_signal.confidence_score,
                            'executed': False
                        }
                
                elif not risk_assessment.is_approved:
                    rejection_reason = f"Nivel de riesgo: {risk_assessment.risk_level.value}"
                    logger.info(f"üö´ Trade rechazado: {rejection_reason}")
                    
                    # Mostrar recomendaciones
                    for rec in risk_assessment.recommendations:
                        logger.info(f"   üí° {rec}")
                    
                    # Actualizar last_signals con la se√±al rechazada
                    self.last_signals[symbol] = {
                        'signal': best_signal,
                        'timestamp': datetime.now(),
                        'action': 'REJECTED',
                        'confidence': best_signal.confidence_score,
                        'executed': False,
                        'rejection_reason': rejection_reason
                    }
                
            except Exception as e:
                logger.error(f"‚ùå Error procesando se√±al para {best_signal.symbol}: {e}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'ERROR',
                    'error': str(e)
                }
            
            # Actualizar P&L total
            self.trading_bot.stats["total_pnl"] = portfolio_summary.get("total_pnl", 0)
            
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico procesando se√±ales para {symbol}: {e}")
            import traceback
            traceback.print_exc()
    
    async def start(self):
        """üöÄ Iniciar el bot de trading en vivo"""
        self.running = True
        logger.info("üöÄ Iniciando Live Trading Bot...")
        logger.info("‚ö†Ô∏è Modo: Paper Trading (Sin dinero real)")
        logger.info("Presiona Ctrl+C para detener")
        
        # Iniciar el TradingBot interno y su position_monitor
        try:
            logger.info("üîß Iniciando TradingBot interno y position_monitor...")
            self.trading_bot.start()  # Esto inicia el position_monitor autom√°ticamente
            logger.info("‚úÖ TradingBot interno y position_monitor iniciados correctamente")
        except Exception as e:
            logger.error(f"‚ùå Error iniciando TradingBot interno: {e}")
            return
        
        # Contador de ciclos para debug
        cycle_count = 0
        
        try:
            while self.running:
                cycle_count += 1
                logger.info(f"üîÑ Ciclo #{cycle_count} - {datetime.now().strftime('%H:%M:%S')}")
                
                # Analizar mercado y ejecutar trades
                await self.analyze_and_trade()
                
                # Mostrar estad√≠sticas actuales
                self.show_current_stats()
                
                logger.info(f"‚è±Ô∏è Esperando {self.update_interval} segundos antes del pr√≥ximo an√°lisis...")
                
                # Esperar antes del siguiente ciclo
                await asyncio.sleep(self.update_interval)
                    
        except KeyboardInterrupt:
            logger.info("üõë Bot detenido por el usuario")
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.running = False
            
            # Detener el TradingBot interno y su position_monitor
            try:
                logger.info("üõë Deteniendo TradingBot interno y position_monitor...")
                self.trading_bot.stop()
                logger.info("‚úÖ TradingBot interno detenido correctamente")
            except Exception as e:
                logger.error(f"‚ùå Error deteniendo TradingBot interno: {e}")
            
            # Mostrar resumen final
            self.show_final_summary()
    
    def show_current_stats(self):
        """üìä Mostrar estad√≠sticas actuales usando datos del TradingBot"""
        try:
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            portfolio_summary = self.trading_bot.paper_trader.get_portfolio_summary()
            
            current_balance = portfolio_performance.get('cash_balance', 0)
            total_value = portfolio_performance.get('total_value', 0)
            pnl = portfolio_performance.get('total_pnl', 0)
            pnl_pct = portfolio_performance.get('total_pnl_percentage', 0)
            
            logger.info("\n" + "="*60)
            logger.info("üìä ESTAD√çSTICAS ACTUALES")
            logger.info("="*60)
            logger.info(f"üí∞ Balance actual: ${current_balance:,.2f}")
            logger.info(f"üìà Valor total del portfolio: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Trades totales: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Tasa de √©xito: {success_rate:.1f}%")
            
            # Mostrar balances de cada activo
            logger.info("\nü™ô BALANCES POR ACTIVO:")
            assets = portfolio_summary.get('assets', [])
            if assets:
                for asset in assets:
                    symbol = asset.get('symbol', '')
                    quantity = asset.get('quantity', 0)
                    current_value = asset.get('current_value', 0)
                    
                    if symbol == 'USDT':
                        # Para USDT solo mostrar el valor
                        logger.info(f"   üíµ {symbol}: ${current_value:,.2f}")
                    else:
                        # Para otros activos mostrar cantidad y valor en USDT
                        logger.info(f"   ü™ô {symbol}: {quantity:.6f} (${current_value:,.2f})")
            else:
                logger.info("   üì≠ No hay activos en el portfolio")
            
            logger.info("="*60 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando estad√≠sticas: {e}")
    
    def show_final_summary(self):
        """üìã Mostrar resumen final de la sesi√≥n usando datos del TradingBot"""
        try:
            session_duration = datetime.now() - self.session_stats['start_time']
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            final_balance = portfolio_performance.get('cash_balance', 0)
            total_value = portfolio_performance.get('total_value', 0)
            total_pnl = portfolio_performance.get('total_pnl', 0)
            pnl_pct = portfolio_performance.get('total_pnl_percentage', 0)
            
            logger.info("\n" + "="*80)
            logger.info("üèÅ RESUMEN FINAL DE LA SESI√ìN")
            logger.info("="*80)
            logger.info(f"‚è±Ô∏è Duraci√≥n de la sesi√≥n: {session_duration}")
            logger.info(f"üí∞ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"üí∞ Balance final: ${final_balance:,.2f}")
            logger.info(f"üìà Valor total final: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${total_pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Total de trades: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Trades exitosos: {self.session_stats['successful_trades']} ({success_rate:.1f}%)")
                avg_pnl = total_pnl / self.session_stats['total_trades']
                logger.info(f"üìä PnL promedio por trade: ${avg_pnl:.2f}")
            logger.info("="*80)
            logger.info("üôè ¬°Gracias por usar el Live Trading Bot!")
            logger.info("="*80 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando resumen final: {e}")

async def main():
    """üéØ Funci√≥n principal"""
    try:
        bot = LiveTradingBot()
        await bot.start()
    except KeyboardInterrupt:
        logger.info("üõë Bot detenido por el usuario")
    except Exception as e:
        logger.error(f"‚ùå Error cr√≠tico en main: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass  # Ya manejado en main()