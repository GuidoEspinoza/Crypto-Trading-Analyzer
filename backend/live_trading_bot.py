#!/usr/bin/env python3
"""
üöÄ Live Trading Bot - Simulador de Trading en Tiempo Real
Bot de trading que muestra logs simples en consola
"""

import asyncio
import os
import sys
import logging
from datetime import datetime, timedelta
from typing import Dict, List
from colorama import Fore, Back, Style, init

# Inicializar colorama para colores en terminal
init(autoreset=True)

# Agregar el directorio backend al path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from trading_engine.trading_bot import TradingBot
from trading_engine.config import TradingBotConfig
from database.database import db_manager

# Configurar logging con colores
class ColoredFormatter(logging.Formatter):
    """Formatter personalizado para agregar colores a los logs"""
    
    COLORS = {
        'DEBUG': Fore.CYAN,
        'INFO': Fore.GREEN,
        'WARNING': Fore.YELLOW,
        'ERROR': Fore.RED,
        'CRITICAL': Fore.MAGENTA + Style.BRIGHT
    }
    
    def format(self, record):
        # Aplicar color seg√∫n el nivel
        color = self.COLORS.get(record.levelname, '')
        record.levelname = f"{color}{record.levelname}{Style.RESET_ALL}"
        
        # Colorear mensajes espec√≠ficos
        message = record.getMessage()
        
        # Colores para diferentes tipos de procesos
        if "üìä Analizando" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîÑ INICIANDO CICLO" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞" in message and "Precio actual" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìà" in message and "RSI" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "üéØ DECISI√ìN FINAL" in message:
            message = f"{Fore.GREEN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚úÖ TRADE EJECUTADO" in message:
            message = f"{Fore.GREEN + Back.BLACK + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üìã CONFIGURACI√ìN DE ESTRATEGIAS" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üí∞ CONFIGURACI√ìN DEL PAPER TRADER" in message:
            message = f"{Fore.YELLOW + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "‚öôÔ∏è CONFIGURACI√ìN DEL BOT" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("üéØ") and ":" in message:
            message = f"{Fore.CYAN}{message}{Style.RESET_ALL}"
        elif message.strip().startswith("‚Ä¢"):
            message = f"{Fore.WHITE + Style.DIM}{message}{Style.RESET_ALL}"
        elif "‚ö†Ô∏è" in message:
            message = f"{Fore.YELLOW}{message}{Style.RESET_ALL}"
        elif "‚ùå" in message:
            message = f"{Fore.RED}{message}{Style.RESET_ALL}"
        elif "üöÄ" in message:
            message = f"{Fore.BLUE + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üíº Ejecutando trade" in message:
            message = f"{Fore.CYAN + Style.BRIGHT}{message}{Style.RESET_ALL}"
        elif "üîç Ejecutando estrategia" in message:
            message = f"{Fore.MAGENTA}{message}{Style.RESET_ALL}"
        elif "‚û°Ô∏è" in message:
            message = f"{Fore.BLUE}{message}{Style.RESET_ALL}"
        
        record.msg = message
        return super().format(record)

# Configurar logger con colores (sin duplicaci√≥n)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Limpiar handlers existentes para evitar duplicaci√≥n
logger.handlers.clear()

# Aplicar el formatter con colores
handler = logging.StreamHandler()
handler.setFormatter(ColoredFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(handler)

# Evitar que los logs se propaguen al logger ra√≠z
logger.propagate = False

class LiveTradingBot:
    """
    üöÄ Bot de trading en vivo con logs simples
    """
    
    def __init__(self):
        self.config = TradingBotConfig()
        self.trading_bot = TradingBot()
        
        # Configuraci√≥n del bot
        self.symbols = TradingBotConfig.SYMBOLS_LIVE_BOT
        self.update_interval = self.config.LIVE_UPDATE_INTERVAL
        self.running = False
        
        # Inicializar estrategias del trading bot
        logger.info("üîß Inicializando estrategias de trading...")
        try:
            # Forzar inicializaci√≥n de estrategias
            self.trading_bot._initialize_strategies()
            logger.info(f"‚úÖ {len(self.trading_bot.strategies)} estrategias inicializadas")
            
            # Mostrar informaci√≥n detallada de cada estrategia
            logger.info("üìã CONFIGURACI√ìN DE ESTRATEGIAS:")
            for strategy_name, strategy in self.trading_bot.strategies.items():
                logger.info(f"   üéØ {strategy_name}:")
                logger.info(f"      ‚Ä¢ Confianza m√≠nima: {strategy.min_confidence}%")
                if hasattr(strategy, 'rsi_oversold'):
                    logger.info(f"      ‚Ä¢ RSI Sobreventa: {strategy.rsi_oversold}")
                if hasattr(strategy, 'rsi_overbought'):
                    logger.info(f"      ‚Ä¢ RSI Sobrecompra: {strategy.rsi_overbought}")
                if hasattr(strategy, 'stop_loss_pct'):
                    logger.info(f"      ‚Ä¢ Stop Loss: {strategy.stop_loss_pct}%")
                if hasattr(strategy, 'take_profit_pct'):
                    logger.info(f"      ‚Ä¢ Take Profit: {strategy.take_profit_pct}%")
            
            # Mostrar configuraci√≥n del Paper Trader
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            logger.info("üí∞ CONFIGURACI√ìN DEL PAPER TRADER:")
            logger.info(f"   ‚Ä¢ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"   ‚Ä¢ Tama√±o m√°ximo por posici√≥n: {self.trading_bot.paper_trader.max_position_size:.1f}%")
            logger.info(f"   ‚Ä¢ Exposici√≥n m√°xima total: {self.trading_bot.paper_trader.max_total_exposure:.1f}%")
            logger.info(f"   ‚Ä¢ Valor m√≠nimo por trade: ${self.trading_bot.paper_trader.min_trade_value}")
            logger.info(f"   ‚Ä¢ Valor actual del portfolio: ${portfolio_performance.get('total_value', 0):,.2f}")
            
            # Mostrar configuraci√≥n del bot
            logger.info("‚öôÔ∏è CONFIGURACI√ìN DEL BOT:")
            logger.info(f"   ‚Ä¢ S√≠mbolos: {', '.join(self.symbols)}")
            logger.info(f"   ‚Ä¢ Intervalo de an√°lisis: {self.update_interval} segundos")
            logger.info(f"   ‚Ä¢ Confianza m√≠nima para trades: {self.config.MIN_CONFIDENCE_THRESHOLD}%")
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando estrategias: {e}")
        
        self.last_signals = {}
        self.session_stats = {
            "start_time": datetime.now(),
            "total_trades": 0,
            "successful_trades": 0,
            "total_pnl": 0.0
        }
    
    def get_status(self):
        """Obtener estado del bot delegando al TradingBot interno"""
        return self.trading_bot.get_status()
    
    def get_detailed_report(self) -> Dict:
        """Obtener reporte detallado del bot delegando al TradingBot interno"""
        return self.trading_bot.get_detailed_report()
    
    def get_configuration(self) -> Dict:
        """
        üìã Obtener configuraci√≥n actual del live trading bot
        """
        try:
            # Obtener configuraci√≥n del trading bot interno
            bot_config = self.trading_bot.get_configuration()
            
            # A√±adir configuraci√≥n espec√≠fica del live bot
            live_config = {
                'live_symbols': self.symbols,
                'update_interval_seconds': self.update_interval,
                'is_live_running': self.running,
                'session_start_time': self.session_stats['start_time'].isoformat(),
                'session_total_trades': self.session_stats['total_trades'],
                'session_successful_trades': self.session_stats['successful_trades'],
                'session_total_pnl': self.session_stats['total_pnl']
            }
            
            # Combinar configuraciones
            return {**bot_config, **live_config}
            
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo configuraci√≥n del live bot: {e}")
            return {}
    

    
    async def analyze_and_trade(self):
        """üîç Analizar mercado y ejecutar trades"""
        try:
            logger.info(f"üîÑ INICIANDO CICLO DE AN√ÅLISIS - {datetime.now().strftime('%H:%M:%S')}")
            
            for symbol in self.symbols:
                logger.info(f"üìä Analizando {symbol}...")
                
                # Obtener precio actual
                try:
                    import ccxt
                    exchange = ccxt.binance({'sandbox': False, 'enableRateLimit': True})
                    ticker = exchange.fetch_ticker(symbol)
                    current_price = ticker['last']
                    logger.info(f"üí∞ {symbol} - Precio actual: ${current_price:,.2f}")
                except Exception as e:
                    logger.error(f"‚ùå Error obteniendo precio para {symbol}: {e}")
                    current_price = 0
                
                # Analizar con cada estrategia del trading bot (igual que trading_bot.py)
                all_signals = []
                
                for strategy_name, strategy in self.trading_bot.strategies.items():
                    try:
                        logger.info(f"üîç Ejecutando estrategia {strategy_name} para {symbol}")
                        
                        # Obtener datos de mercado para mostrar indicadores
                        try:
                            df = strategy.get_market_data(symbol, "1h", 50)
                            if not df.empty:
                                last_close = df['close'].iloc[-1]
                                volume_avg = df['volume'].rolling(20).mean().iloc[-1]
                                current_volume = df['volume'].iloc[-1]
                                
                                # Calcular algunos indicadores b√°sicos
                                import pandas_ta as ta
                                rsi = ta.rsi(df['close'], length=14).iloc[-1]
                                sma_20 = ta.sma(df['close'], length=20).iloc[-1]
                                sma_50 = ta.sma(df['close'], length=50).iloc[-1]
                                
                                logger.info(f"üìà {symbol} - RSI: {rsi:.1f}, SMA20: ${sma_20:.2f}, SMA50: ${sma_50:.2f}")
                                logger.info(f"üìä {symbol} - Volumen: {current_volume:,.0f} (Promedio: {volume_avg:,.0f})")
                                
                        except Exception as e:
                            logger.error(f"‚ùå Error obteniendo indicadores para {symbol}: {e}")
                        
                        # Ejecutar an√°lisis de la estrategia
                        signal = strategy.analyze(symbol)
                        
                        logger.info(f"‚û°Ô∏è {strategy_name} - {symbol}: {signal.signal_type} (Confianza: {signal.confidence_score:.1f}%)")
                        
                        # Agregar se√±al a la lista si no es HOLD
                        if signal.signal_type != "HOLD":
                            all_signals.append(signal)
                            
                    except Exception as e:
                        logger.error(f"‚ùå Error en estrategia {strategy_name} para {symbol}: {e}")
                
                # Procesar se√±ales usando la misma l√≥gica que trading_bot.py
                if all_signals:
                    self._process_signals_for_symbol(symbol, all_signals)
                else:
                    logger.info(f"‚ö™ No se generaron se√±ales de trading para {symbol}")
                    self.last_signals[symbol] = {
                        'signal': None,
                        'timestamp': datetime.now(),
                        'action': 'HOLD'
                    }
                

                
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico en an√°lisis: {e}")
            import traceback
            traceback.print_exc()
    
    def _show_binance_config(self, signal, trade_result):
        """
        üìã Mostrar configuraci√≥n para replicar en Binance
        """
        try:
            # Extraer datos del trade ejecutado
            symbol = signal.symbol
            signal_type = signal.signal_type
            price = trade_result.entry_price if hasattr(trade_result, 'entry_price') else signal.current_price
            
            # Calcular valores para Binance
            if signal_type == "BUY":
                # Precio ligeramente por debajo para mejor ejecuci√≥n
                binance_price = price * 0.9997  # 0.03% por debajo
                
                # Monto en cripto (del trade ejecutado)
                crypto_amount = trade_result.quantity if hasattr(trade_result, 'quantity') else 0
                
                # Total en USDT
                total_usdt = trade_result.entry_value if hasattr(trade_result, 'entry_value') else (crypto_amount * price)
                
                # Take Profit (3% arriba)
                take_profit_price = price * 1.03
                take_profit_pct = 3.0
                
                # Stop Loss (3% abajo)
                stop_loss_price = price * 0.97
                stop_loss_pct = 3.0
                
                logger.info("")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("üìã CONFIGURACI√ìN PARA BINANCE SPOT - ORDEN L√çMITE")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info(f"üí∞ PRECIO:     {binance_price:,.2f} USDT")
                logger.info(f"ü™ô MONTO:      {crypto_amount:.8f} {symbol.replace('USDT', '')}")
                logger.info(f"üíµ TOTAL:      {total_usdt:.2f} USDT")
                logger.info("")
                logger.info("üõ°Ô∏è PROTECCI√ìN (TP/SL):")
                logger.info(f"üìà TAKE PROFIT: {take_profit_price:,.2f} USDT (+{take_profit_pct:.1f}%)")
                logger.info(f"üìâ STOP LOSS:   {stop_loss_price:,.2f} USDT (-{stop_loss_pct:.1f}%)")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("")
                
            elif signal_type == "SELL":
                # Para ventas
                binance_price = price * 1.0003  # 0.03% por arriba
                
                # Obtener balance actual del activo
                from database.database import db_manager
                portfolio = db_manager.get_portfolio_summary(is_paper=True)
                asset_name = symbol.replace('USDT', '')
                crypto_balance = portfolio.get('assets', {}).get(asset_name, 0)
                
                total_usdt = crypto_balance * price
                
                logger.info("")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("üìã CONFIGURACI√ìN PARA BINANCE SPOT - VENTA L√çMITE")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info(f"üí∞ PRECIO:     {binance_price:,.2f} USDT")
                logger.info(f"ü™ô MONTO:      {crypto_balance:.8f} {asset_name}")
                logger.info(f"üíµ TOTAL:      {total_usdt:.2f} USDT")
                logger.info("üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                logger.info("")
                
        except Exception as e:
            logger.error(f"‚ùå Error mostrando configuraci√≥n de Binance: {e}")
    
    def _process_signals_for_symbol(self, symbol: str, signals):
        """
        üéØ Procesar y ejecutar se√±ales de trading para un s√≠mbolo espec√≠fico
        
        Args:
            symbol: S√≠mbolo del activo
            signals: Lista de se√±ales generadas para este s√≠mbolo
        """
        try:
            # Filtrar se√±ales por confianza m√≠nima
            high_confidence_signals = [
                signal for signal in signals 
                if signal.confidence_score >= self.trading_bot.min_confidence_threshold
            ]
            
            if not high_confidence_signals:
                logger.info(f"üìâ No hay se√±ales por encima del umbral de confianza ({self.trading_bot.min_confidence_threshold}%) para {symbol}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'HOLD'
                }
                return
            
            # Ordenar por confianza (mayor primero)
            high_confidence_signals.sort(key=lambda x: x.confidence_score, reverse=True)
            
            # Obtener valor actual del portfolio
            from database.database import db_manager
            portfolio_summary = db_manager.get_portfolio_summary(is_paper=True)
            portfolio_value = portfolio_summary.get("total_value", self.trading_bot.config.DEFAULT_PORTFOLIO_VALUE)
            
            logger.info(f"üíº Valor actual del portfolio: ${portfolio_value:,.2f}")
            
            # Procesar la mejor se√±al para este s√≠mbolo
            best_signal = high_confidence_signals[0]
            
            try:
                # Verificar l√≠mite diario
                if self.trading_bot.stats["daily_trades"] >= self.trading_bot.max_daily_trades:
                    logger.info("‚è∏Ô∏è L√≠mite diario de trades alcanzado")
                    return
                
                # An√°lisis de riesgo
                risk_assessment = self.trading_bot.risk_manager.assess_trade_risk(best_signal, portfolio_value)
                
                logger.info(f"üõ°Ô∏è Evaluaci√≥n de riesgo para {best_signal.symbol}:")
                logger.info(f"   - Puntuaci√≥n de Riesgo: {risk_assessment.overall_risk_score:.1f}/100")
                logger.info(f"   - Tama√±o de Posici√≥n: {risk_assessment.position_sizing.recommended_size:.2f}")
                logger.info(f"   - Aprobado: {risk_assessment.is_approved}")
                logger.info(f"   - Nivel de Riesgo: {risk_assessment.risk_level.value}")
                
                # Ejecutar si est√° aprobado
                if risk_assessment.is_approved and self.trading_bot.enable_trading:
                    trade_result = self.trading_bot.paper_trader.execute_signal(best_signal)
                    
                    if trade_result.success:
                        self.trading_bot.stats["trades_executed"] += 1
                        self.trading_bot.stats["daily_trades"] += 1
                        self.session_stats["total_trades"] += 1
                        
                        # Determinar si fue exitoso (simplificado)
                        if "profit" in trade_result.message.lower() or trade_result.entry_value > 0:
                            self.trading_bot.stats["successful_trades"] += 1
                            self.session_stats["successful_trades"] += 1
                        
                        logger.info(f"‚úÖ Trade ejecutado: {trade_result.message}")
                        
                        # Mostrar configuraci√≥n para Binance
                        self._show_binance_config(best_signal, trade_result)
                        
                        # Actualizar last_signals con la se√±al ejecutada
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': best_signal.signal_type,
                            'confidence': best_signal.confidence_score,
                            'executed': True
                        }
                    else:
                        logger.warning(f"‚ùå Trade fall√≥: {trade_result.message}")
                        self.last_signals[symbol] = {
                            'signal': best_signal,
                            'timestamp': datetime.now(),
                            'action': 'FAILED',
                            'confidence': best_signal.confidence_score,
                            'executed': False
                        }
                
                elif not risk_assessment.is_approved:
                    rejection_reason = f"Nivel de riesgo: {risk_assessment.risk_level.value}"
                    logger.info(f"üö´ Trade rechazado: {rejection_reason}")
                    
                    # Mostrar recomendaciones
                    for rec in risk_assessment.recommendations:
                        logger.info(f"   üí° {rec}")
                    
                    # Actualizar last_signals con la se√±al rechazada
                    self.last_signals[symbol] = {
                        'signal': best_signal,
                        'timestamp': datetime.now(),
                        'action': 'REJECTED',
                        'confidence': best_signal.confidence_score,
                        'executed': False,
                        'rejection_reason': rejection_reason
                    }
                
            except Exception as e:
                logger.error(f"‚ùå Error procesando se√±al para {best_signal.symbol}: {e}")
                self.last_signals[symbol] = {
                    'signal': None,
                    'timestamp': datetime.now(),
                    'action': 'ERROR',
                    'error': str(e)
                }
            
            # Actualizar P&L total
            self.trading_bot.stats["total_pnl"] = portfolio_summary.get("total_pnl", 0)
            
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico procesando se√±ales para {symbol}: {e}")
            import traceback
            traceback.print_exc()
    
    async def start(self):
        """üöÄ Iniciar el bot de trading en vivo"""
        self.running = True
        logger.info("üöÄ Iniciando Live Trading Bot...")
        logger.info("‚ö†Ô∏è Modo: Paper Trading (Sin dinero real)")
        logger.info("Presiona Ctrl+C para detener")
        
        # Contador de ciclos para debug
        cycle_count = 0
        
        try:
            while self.running:
                cycle_count += 1
                logger.info(f"üîÑ Ciclo #{cycle_count} - {datetime.now().strftime('%H:%M:%S')}")
                
                # Analizar mercado y ejecutar trades
                await self.analyze_and_trade()
                
                # Mostrar estad√≠sticas actuales
                self.show_current_stats()
                
                logger.info(f"‚è±Ô∏è Esperando {self.update_interval} segundos antes del pr√≥ximo an√°lisis...")
                
                # Esperar antes del siguiente ciclo
                await asyncio.sleep(self.update_interval)
                    
        except KeyboardInterrupt:
            logger.info("üõë Bot detenido por el usuario")
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico: {e}")
            import traceback
            traceback.print_exc()
        finally:
            self.running = False
            # Mostrar resumen final
            self.show_final_summary()
    
    def show_current_stats(self):
        """üìä Mostrar estad√≠sticas actuales usando datos del TradingBot"""
        try:
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            current_balance = portfolio_performance.get('cash_balance', 0)
            total_value = portfolio_performance.get('total_value', 0)
            pnl = portfolio_performance.get('total_pnl', 0)
            pnl_pct = portfolio_performance.get('total_pnl_percentage', 0)
            
            logger.info("\n" + "="*60)
            logger.info("üìä ESTAD√çSTICAS ACTUALES")
            logger.info("="*60)
            logger.info(f"üí∞ Balance actual: ${current_balance:,.2f}")
            logger.info(f"üìà Valor total del portfolio: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Trades totales: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Tasa de √©xito: {success_rate:.1f}%")
            logger.info("="*60 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando estad√≠sticas: {e}")
    
    def show_final_summary(self):
        """üìã Mostrar resumen final de la sesi√≥n usando datos del TradingBot"""
        try:
            session_duration = datetime.now() - self.session_stats['start_time']
            portfolio_performance = self.trading_bot.paper_trader.calculate_portfolio_performance()
            final_balance = portfolio_performance.get('cash_balance', 0)
            total_value = portfolio_performance.get('total_value', 0)
            total_pnl = portfolio_performance.get('total_pnl', 0)
            pnl_pct = portfolio_performance.get('total_pnl_percentage', 0)
            
            logger.info("\n" + "="*80)
            logger.info("üèÅ RESUMEN FINAL DE LA SESI√ìN")
            logger.info("="*80)
            logger.info(f"‚è±Ô∏è Duraci√≥n de la sesi√≥n: {session_duration}")
            logger.info(f"üí∞ Balance inicial: ${self.trading_bot.paper_trader.initial_balance:,.2f}")
            logger.info(f"üí∞ Balance final: ${final_balance:,.2f}")
            logger.info(f"üìà Valor total final: ${total_value:,.2f}")
            logger.info(f"üíµ PnL total: ${total_pnl:,.2f} ({pnl_pct:+.2f}%)")
            logger.info(f"üéØ Total de trades: {self.session_stats['total_trades']}")
            if self.session_stats['total_trades'] > 0:
                success_rate = (self.session_stats['successful_trades'] / self.session_stats['total_trades']) * 100
                logger.info(f"‚úÖ Trades exitosos: {self.session_stats['successful_trades']} ({success_rate:.1f}%)")
                avg_pnl = total_pnl / self.session_stats['total_trades']
                logger.info(f"üìä PnL promedio por trade: ${avg_pnl:.2f}")
            logger.info("="*80)
            logger.info("üôè ¬°Gracias por usar el Live Trading Bot!")
            logger.info("="*80 + "\n")
        except Exception as e:
            logger.error(f"‚ùå Error mostrando resumen final: {e}")

async def main():
    """üéØ Funci√≥n principal"""
    try:
        bot = LiveTradingBot()
        await bot.start()
    except KeyboardInterrupt:
        logger.info("üõë Bot detenido por el usuario")
    except Exception as e:
        logger.error(f"‚ùå Error cr√≠tico en main: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass  # Ya manejado en main()